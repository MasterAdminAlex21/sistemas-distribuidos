********************************************************************************
//Makefile para compilar 

a.out: SocketDatagrama.o servidor.cpp PaqueteDatagrama.o LeerDirectorio.o archivos.o
	g++ servidor.cpp SocketDatagrama.o PaqueteDatagrama.o LeerDirectorio.o archivo.o -std=c++0x -o servidor

LeerDirectorio.o: LeerDirectorio.cpp
	g++ LeerDirectorio.cpp -c
archivos.o: archivo.cpp
	g++ archivo.cpp -c
SocketDatagrama.o: SocketDatagrama.cpp SocketDatagrama.h PaqueteDatagrama.o
	g++ SocketDatagrama.cpp -c
PaqueteDatagrama.o: PaqueteDatagrama.cpp PaqueteDatagrama.h
	g++ PaqueteDatagrama.cpp -c

clean:
	rm servidor *.o 

*********************************************************************************
//LeerDirectorio.cpp

#include <iostream>
#include <dirent.h>
#include <string.h>
#include "LeerDirectorio.h"

using namespace std;

LeerDirectorio::LeerDirectorio(const string &dir) {
	directorio = dir;
}

vector<string> LeerDirectorio::evaluar() {
	vector<string> archivos;
	
	DIR *dir;
	dir = opendir(directorio.c_str());
	
	if (dir == NULL) {
		cout << "No se pudo abrir el directorio." << endl;
		return archivos;
	}
	
	struct dirent *ent;
	while ((ent = readdir(dir)) != NULL) {
		//std::cout << directorio << std::endl;
		if ((strcmp(ent->d_name, ".") != 0) && (strcmp(ent->d_name, "..") != 0)) {
			//std::cout << "Archivo: " << ent->d_name << std::endl;
			archivos.push_back(std::string(ent->d_name));
		}
	}
	return archivos;	
}

**********************************************************************************
//LeerDirectorio.h

#ifndef LEERDIRECTORIO_H
#define LEERDIRECTORIO_H

#include <vector>
#include <string>
using namespace std;

class LeerDirectorio {
private:
	string directorio;
public:
	LeerDirectorio(const string&);
	vector<string> evaluar();
};

#endif

**********************************************************************************
//header.h

/* Definiciones necesarias para los clientes y el servidor de archivos */
#define MAX_PATH 255
//Longitud máxima en el nombre de un archivo
#define BUF_SIZE 1000 //Cantidad de bytes que se transfieren por paquete
/* Definición de las operaciones permitidas */
#define CREATE 1 //Crea un nuevo archivo
#define READ   2 //Lee una parte del archivo
#define WRITE  3 //Escribe una parte del archivo
#define DELETE 4 //Elimina un archivo existente
/*Códigos de error */
#define OK				0 //Operación correcta
#define E_BAD_OPCODE	-1 //Operación desconocida
#define E_BAD_PARAM		-2 //Error en un parámetro
#define E_IO			-3 //Error en disco u otro error de E/S

/* Formato del mensaje que viaja del cliente hacia el servidor. El tipo de dato numérico
uint32_t está definido en inttypes.h y es consistente entre computadoras distintas e
independiente del sistema operativo */

struct messageCS{
	uint32_t opcode; //Código de la operación solicitada por el cliente
	uint32_t count; //Numero de bytes útiles (leídos o por escribir), devuelto por el servidor en READ y enviado por el cliente en WRITE
	uint32_t offset;//Lugar del archivo donde se debe iniciar la lectura o escritura, enviado por el cliente 
	char name[MAX_PATH]; //Nombre del archivo sobre el cual se opera
};
/* Formato del mensaje que viaja del servidor hacia el cliente */

struct messageSC{
	uint32_t count; //Numero de bytes útiles, devuelto por el servidor en READ y enviado por el cliente en WRITE
	uint32_t result; //Código de error devuelto por el servidor
    uint32_t offset;
	char data[BUF_SIZE]; //Datos del archivo
};

***********************************************************************************
//PaqueteDatagrama.cpp

#include "PaqueteDatagrama.h"

PaqueteDatagrama::PaqueteDatagrama(char *msj, unsigned int lon, char *IP, int p) {
	longitud = lon;
	puerto = p;
	datos = new char[lon];
	memcpy(datos, msj, lon);
	strcpy(ip, IP);
}

PaqueteDatagrama::PaqueteDatagrama(unsigned int lon){
	longitud = lon;
	datos = new char[lon]();
}

PaqueteDatagrama::~PaqueteDatagrama(){
	delete datos;
	longitud = 0;
	puerto = 0;
}

char *PaqueteDatagrama::obtieneDireccion(){
	return ip;
}

unsigned int PaqueteDatagrama::obtieneLongitud(){
	return longitud;
}

int PaqueteDatagrama::obtienePuerto(){
	return puerto;
}

char * PaqueteDatagrama::obtieneDatos(){
	return datos;
}

void PaqueteDatagrama::inicializaPuerto(int p){
	puerto = p;
}

void PaqueteDatagrama::inicializaIp(char *IP){
	strcpy(ip, IP);
}

void PaqueteDatagrama::inicializaDatos(char *d){
	memcpy(datos, d, longitud);	
}

***********************************************************************************
//PaqueteDatagrama.h

#ifndef PAQUETEDATAGRAMA_H_
#define PAQUETEDATAGRAMA_H_

#include <iostream>
#include <string.h>

class PaqueteDatagrama{
public:
	PaqueteDatagrama(char *, unsigned int, char *, int);
	PaqueteDatagrama(unsigned int);
	~PaqueteDatagrama();
	char *obtieneDireccion();          
	unsigned int obtieneLongitud();
	int obtienePuerto();
	char *obtieneDatos();
	void inicializaPuerto(int);
	void inicializaIp(char *);
	void inicializaDatos(char *);
private:
	char *datos;
	//Almacena los datos
	char ip[16];
	//Almacena la IP 
	unsigned int longitud;
	//Almacena la longitude de la cadena de datos
	int puerto;  
	//Almacena el puerto
};  

#endif

*************************************************************************************
//SocketDatagrama.cpp

#include "SocketDatagrama.h"

SocketDatagrama :: SocketDatagrama(int puerto){
	s = socket(AF_INET, SOCK_DGRAM, 0);
	bzero((char *)&direccionLocal, sizeof(direccionLocal));
   	direccionLocal.sin_family = AF_INET;
   	direccionLocal.sin_addr.s_addr = INADDR_ANY;
   	direccionLocal.sin_port = htons(puerto);
   	bind(s, (struct sockaddr *)&direccionLocal, sizeof(direccionLocal));
}

SocketDatagrama :: ~SocketDatagrama(){
	bzero((char *)&direccionLocal, sizeof(direccionLocal));
	close(s);
}

int SocketDatagrama::recibe(PaqueteDatagrama &p){
	socklen_t clilen =  sizeof(direccionForanea);
	int r = recvfrom(s, p.obtieneDatos(), p.obtieneLongitud(), 0, (struct sockaddr *)&direccionForanea, &clilen);
	p.inicializaPuerto(ntohs(direccionForanea.sin_port));
	inet_ntop(AF_INET, &(direccionForanea.sin_addr), p.obtieneDireccion(), INET_ADDRSTRLEN);
	std :: cout << "\n"<< p.obtieneDireccion() << " - "<< p.obtienePuerto() << "   dice, buscar palabra: ";
	return r; 
}

int SocketDatagrama::envia(PaqueteDatagrama &p){
	socklen_t clilen =  sizeof(direccionForanea);
	bzero((char *)&direccionForanea, sizeof(direccionForanea));
   	direccionForanea.sin_family = AF_INET;
   	direccionForanea.sin_addr.s_addr = inet_addr(p.obtieneDireccion());
   	direccionForanea.sin_port = htons(p.obtienePuerto());
	int r = sendto(s,(char *) p.obtieneDatos(), p.obtieneLongitud(), 0, (struct sockaddr *)&direccionForanea, sizeof(direccionForanea));
	//std :: cout << "Direccion IP del paquete a enviar: " << p.obtieneDireccion() << std :: endl;
	//std :: cout << "Puerto del paquete enviado: " << p.obtienePuerto() << std :: endl;
	return r;
}


*************************************************************************************
//SocketDatagrama.h

#ifndef SOCKETDATAGRAMA_H_
#define SOCKETDATAGRAMA_H_

#include <arpa/inet.h>
#include <errno.h>
#include <iostream>
#include <netdb.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <strings.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <unistd.h>

#include "PaqueteDatagrama.h"

class SocketDatagrama{
private:
	struct sockaddr_in direccionLocal;
	struct sockaddr_in direccionForanea;
	int s; //ID socket
public:
	SocketDatagrama(int);
	~SocketDatagrama();
	//Recibe un paquete tipo datagrama proveniente de este socket
	int recibe(PaqueteDatagrama &p);
	//Envía un paquete tipo datagrama desde este socket
	int envia(PaqueteDatagrama &p);
};

#endif

*************************************************************************************
//servidor.cpp

#include "SocketDatagrama.h"
#include <bits/stdc++.h>
#include "archivo.h"
#include "LeerDirectorio.h"
#include "header.h"
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
using namespace std;

#define BUF_SIZE 1000

int main(int args, char *argv[]) {
	if (args != 4){
		cout << "Modo de uso: correr primeramente el cliente" << endl;
		cout << "./servidor IP PuertoServidor PuertoCliente" << endl;
		return 0;
	}
	string CARPETA = "libros_pruebas/";
	char *IP = argv[1];
	int PUERTO = atoi(argv[2]);
	int PUERTOCli = atoi(argv[3]);
	struct messageCS casteo;
	int  leidos = 0, destino;

	SocketDatagrama sock(PUERTO);
	cout << "Correr primeramente el cliente\nEsperando palabra...\n" << endl;
	struct messageSC sol;
	sol.count  = BUF_SIZE;
	sol.result = OK;
	sol.offset = 1;
	strcpy(sol.data, argv[3]);
	PaqueteDatagrama datos((char *)&sol, sizeof(struct messageSC), IP, PUERTOCli);
	sock.envia(datos);

	PaqueteDatagrama resp(sizeof(messageCS));
	//recibe msj con la palabra
	sock.recibe(resp);
	memcpy(&casteo, resp.obtieneDatos(), sizeof(messageSC));
	//string palabra = resp.obtieneDatos();
	string palabra = casteo.name;
	cout << palabra << endl;

	//abrimos directorio
	LeerDirectorio folder("./" + CARPETA);
	auto libros = folder.evaluar();
	sort(libros.begin(), libros.end());

	//realizamos la busqueda en c/u de los archivos 
	string abrir;
	int tam = palabra.length(), of[100];
	int array_size = 10000, offset;
	int posicion = 0;  
	char datEnvio[150];
	string envioString;

	for (const auto& nombre : libros){
		offset = 0;
		ifstream inFile;
		abrir = "./" + CARPETA + nombre;
		inFile.open(abrir);
		envioString = nombre + "\noffset: ";
		//cout << cstr <<endl;
		if(inFile){
			//cout << "\nBuscando en: " << nombre << endl;
			char * array = new char[array_size]; 
			posicion = 0; 

			while(!inFile.eof() && posicion < array_size){
				inFile.get(array[posicion]); 
				posicion++;
			}
			array[posicion-1] = '\0'; 

			for(int i = 0; array[i] != '\0'; i++){
				for(int j = 0; palabra[j] != '\0' && j < tam ; j++){
			        if(array[i] != palabra[j])
			        	break;
			        else{
			         	i++;
			          	if(palabra[j+1] == '\0'){
			          		offset = i-tam;
			          		if(i!=0)
			          			envioString = envioString + ", ";
			          		envioString = envioString + to_string(offset);
			          		//strcat(cadena1,cadena2);
				            //cout << "Word Found in File at position " << (i-tam) << endl;
			          	}
			        }
	      		}
			}
			envioString = envioString + ";\n";
			//cout << envioString << endl;
			const char * c = envioString.c_str();
			//enviamos informacion del libro 
			struct messageSC solicitud;
			solicitud.count  = BUF_SIZE;
			solicitud.result = OK;
			solicitud.offset = 1;
			strcpy(solicitud.data, c);

			PaqueteDatagrama datos((char *)&solicitud, sizeof(struct messageSC), IP, PUERTOCli);
			sock.envia(datos);
			//cout << "se envio datos de 1 libro.." << endl;
			
		}
		else
			cout << "\nNo se pudo abrir: " << nombre << endl;
	}	
	cout << "Listo! " << endl;
	while(1){}
	close(destino);
	return 0;
}
